<!DOCTYPE html>
<html lang="en">

  <head>
    
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Josh Shi: Pyrus, A Programming Game to Support Problem-Solving Behaviors</title>
  <meta name="description" content="Over the past few quarters, my partner and I have been working on a research project focused on learning more about how we might design a collaborative codin...">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2018/01/01/pyrus.html">
  <link rel="alternate" type="application/rss+xml" title="josh shi" href="/feed.xml">
  <link href="https://fonts.googleapis.com/css?family=Space+Mono" rel="stylesheet">
  <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

  
</head>


  <body>

    

    <article class="container" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="info-container mono">
    <div class="header-sticky">
      <p><a href="/">Josh Shi</a></p>
    </div>
  </div>
  <div class="post-container sans" itemprop="articleBody">
    <header class="post-header">
      
        <p class="sans post-title" itemprop="name headline">Pyrus, A Programming Game to Support Problem-Solving Behaviors: <span>Supporting problem-solving behaviors among novice programmers using game mechanics.</span></p>
      
      <p class="sans post-date">January 01, 2018</p>
    </header>
    <p>Over the past few quarters, my partner and I have been working on a research project focused on learning more about how we might design a collaborative coding game which helps novice computer science students develop their programming problem-solving skills. Our system is called <a href="https://en.wikipedia.org/wiki/Pear">Pyrus</a> and the project is advised by Nell O’Rourke as part of a class called Design, Technology and Research. We recently submitted a paper to CHI 2018’s Student Research Competition, which focuses mostly on the design arguments for our system and our research contributions, but didn’t give us a chance to talk about some of the interesting technical challenges we faced. In this post, I’ll be going over how we handled one interesting technical hurdle by using Redux on the back-end to synchronize game state between a server and multiple clients.</p>

<p>Update: Pyrus placed first at CHI SRC (read our extended abstract <a href="/assets/pyrus-src-paper.pdf">here</a>)! If you’re interested in talking about designing programming games to support problem-solving, feel free to email me at hi at joshshi dot com.</p>

<h2 id="the-challenge">The Challenge</h2>
<p>To provide some context, our system consists of a game which has a few standard game-like components, like a board and a deck of cards. In this game, players can take actions that mutate the state of the game across multiple components, e.g. drawing a card would pop a card off the top of the deck and push it onto the player’s hand. All these changes need to be propagated to all clients in real time and must be handled the same way to ensure that state changes are consistent.</p>

<p>We went back and forth on a few different methods for managing state, but we eventually realized that Redux was probably the best way to go for a couple of reasons:</p>

<ol>
  <li>
    <p>From a bit of digging online, we realized the <a href="https://gamedev.stackexchange.com/questions/28820/how-do-i-sync-multiplayer-game-state-more-efficiently-than-full-state-updates">typical</a> way to keep state in sync between a server (the source of truth) and multiple clients in multiplayer games is to keep game state stored in a well-defined object model and <em>transmit all changes to game state as discrete events</em>. This is pretty much Redux’s bread and butter.</p>
  </li>
  <li>
    <p>Using Redux on the back-end meant we could reuse much of our Redux code (e.g. actions, reducers, etc) on the front-end. Not only did it save us a lot of time from not having to write and maintain two sets of code that did the same thing, it also ensured that all actions were handled in exactly the same way between client and server.</p>
  </li>
  <li>
    <p>We also needed the ability to intercept actions (e.g. in order to log them to a file) as they were dispatched. Redux allows you to do this really well through middleware.</p>
  </li>
</ol>

<p>But there was one sticking point: Redux is usually paired with a view library like React, and we weren’t able to find much information online about Redux being used on the server. This meant we had our work cut out for us as far as figuring out the best way to organize our application.</p>

<h2 id="the-solution">The Solution</h2>
<p>Our solution was to create a Game class which configures a Redux store in its constructor. Once a Game object is instantiated, its store becomes a member variable of that object, i.e. accessible through <code class="highlighter-rouge">this._store</code>. This is what we use in place of traditional member variables to mutate the state of the game. Now any time we want to dispatch an action, we can simply call <code class="highlighter-rouge">this._store.dispatch(someActionCreator());</code> from within the Game itself.</p>

<p>Being able to do this is nice because it affords us a few benefits:</p>

<ol>
  <li>
    <p>We can expose a very simple API for interacting with the Game object. Outside code can call methods like <code class="highlighter-rouge">game.start()</code> instead of dispatching actions directly on a store themselves. (This abstraction carries over to all other objects, like our object for Deck or Board, since we construct those from the Game object we pass down the store to them too.) Additionally, if we ever need to fire multiple actions in sequence, we can just do that in a very straightforward way by simply writing out those dispatches one after another. No messing with thunks necessary.</p>
  </li>
  <li>
    <p>We can also keep all the business logic in the classes. There are a lot of checks in place to make sure that the game doesn’t end up in an invalid state, e.g. by allowing an inactive player to make a move or by executing an action that was actually illegal. Without a class to wrap all these checks around, they would probably all end up in the action. This object-oriented approach makes our code much easier to understand.</p>
  </li>
  <li>
    <p>This also provides an easy, reliable way to access member variables. Instead of keeping a laundry list of member variables that we mutate ourselves, we define getters which simply return the corresponding attribute via a call to  <code class="highlighter-rouge">this.store.getState().attrib</code> within the class. This means we can avoid storing redundant information.</p>
  </li>
</ol>

<p>To take a look at how this works in practice, here’s some annotated example code (the following snippet is close to our implementation, but with some simplifications made for illustration purposes):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'redux'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">rootReducer</span> <span class="k">from</span> <span class="s1">'../../reducers'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">gameStart</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'../../actions/game'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Board</span> <span class="k">from</span> <span class="s1">'../Board'</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Game</span> <span class="p">{</span>
  <span class="c1">// the constructor initializes the Redux store and puts it</span>
  <span class="c1">// in a member variable of the Game object</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">);</span>
    <span class="c1">// the "board" here is an object which encapsulates all</span>
    <span class="c1">// "physical" game components, e.g. players and the deck.</span>
    <span class="c1">// all components get passed the store</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Board</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_store</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// this getter exposes a clean way for outside code to get</span>
  <span class="c1">// information from the Redux store without having to know</span>
  <span class="c1">// the actual layout of the store tree</span>
  <span class="kd">get</span> <span class="nx">status</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_store</span><span class="p">.</span><span class="nx">getState</span><span class="p">().</span><span class="nx">game</span><span class="p">.</span><span class="nx">status</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// returns whether the game successfully started</span>
  <span class="nx">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// a check to make sure we don't end up in an invalid</span>
    <span class="c1">// state (i.e. starting the game when we shouldn't be.</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">!==</span> <span class="s1">'GAME_STATUS_INIT'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// to mutate state, we dispatch actions to our this._store</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">gameStart</span><span class="p">());</span>
    <span class="c1">// we can easily dispatch multiple subsequent actions</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">players</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// like status above, board.players is actually a getter</span>
      <span class="c1">// that fetches an attribute from the state tree</span>
      <span class="kd">const</span> <span class="nx">player</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">players</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// bonus: the deck.draw function called here also</span>
      <span class="c1">// dispatches multiple actions to the store. since</span>
      <span class="c1">// we passed in the store in the board, which in turn</span>
      <span class="c1">// passes it to the deck, we can implement the draw</span>
      <span class="c1">// function in the deck and provide a much simpler</span>
      <span class="c1">// abstraction to use here</span>
      <span class="kd">const</span> <span class="nx">hand</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">deck</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">setPlayerHand</span><span class="p">(</span><span class="nx">hand</span><span class="p">,</span> <span class="nx">player</span><span class="p">.</span><span class="nx">id</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As mentioned above, using the same representation of game state on the server and the client made managing updates between clients really easy. We basically set up a WebSocket connection between the server and all the clients whenever a new client joins a game. On that connection, the server sends over the JSON representation of the current game state. Once that connection is established, the client will send a message to the server whenever the player performs an action (the <code class="highlighter-rouge">JSON.stringify()</code>’d Redux action). The server takes each message, parses it, does all the necessary checking, and handles that action. Attached to the store on the back-end is some custom middleware that intercepts every dispatched action and broadcasts it to all clients listening on that WebSocket connection. Those clients then receive those incoming WebSocket messages and dispatch each action on their own stores. This way, we guarantee that every state mutation the server applies is sent to the client as well.</p>

<p>This was an interesting problem to think through and it definitely took some time before we fell into a comfortable paradigm with it, but in the end I think it worked out really well. The ease of moving between the front- and back-end codebases, possible because that were both in Javascript they shared almost all their Redux code, was actually tremendously helpful.</p>

<p>I was thinking about abstracting some of the work we’ve done into a generalizable framework for writing multiplayer games in a full Javascript stack, but then a friend of mine recently pointed me to <a href="https://github.com/google/boardgame.io">boardgame.io</a>. At time of writing it’s pretty new, but it provides a good layer of abstraction over all that state-management stuff and is conceptually very similar to what I outlined above. Check it out if you’re interested in a solution similar to what I’ve discussed that’s ready out-of-the-box.</p>

  </div>

  
</article>


    <footer class="footer">
</footer>


  </body>

</html>
